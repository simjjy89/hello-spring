# 고차함수 : 파라미터와 반환값으로 람다 사용

- 함수타입
- 고차함수와 코드를 구조화 할 때 고차함수를 사용하는 방법
- 인라인 함수
- 비로컬 retrun과 레이블
- 무명함수



### 고차함수란?

다른 함수를 인자로 받거나 함수를 반환하는 함수.

코틀린은 람다나 함수 참조를 사용해 값으로 함수를 값으로 표현 할 수 있음.

>#### 람다식
>
>{X: Int, y: Int -> x+y }

> 함수 참조
>
> SomeClass :: Method





#### 함수 타입 선언

람다를 인자로 받는 함수를 정의하려면 먼저 람다 인자의 타입을 어떻게 선언할 수 있는지 알아야함.

함수의 타입을 정의하려면 함수 파라미터의 타입을 괄호 안에 넣고, 그 뒤에 화살표를 추가한 다음, 함수의 반환 타입을 지정하면 됨.

```kotlin
      |파라미터 타입|  |반환 타입|
val sum: (Int, Int) -> Int = { x, y -> x + y } //Int 파라미터 두개를 받아서 Int로 반환하는함수
val action:() -> Unit = { println(42) } //아무 인자도 받지 않고 아무 값도 반환하지 않는 함수
```

이렇게 변수타입을 함수타입으로 지정하면 함수타입에 있는 파라미터로 지정하면 굳이 파라미터의 타입을 적을 필요가 없다



널이 될수 있는 함수 타입이나 함수 타입 자체가 널이 될 수 있는 타입임을 선얼 할 수 있음

```kotlin
var canReturnNull: (Int, Int) -> Int? = { x, y -> null } //반환 타입이 null이 될 수 있음
var funOrNull: ((Int, Int) -> Int)? = null
```



#### 고차 함수 구현

```kotlin
fun twoAndThree(operation: (Int,Int) -> Int){   //함수타입 파라미터 선언
    val result = operation(2,3)  	//함수타입 파라미터 호출
    println("The result is $result")
}

>> twoAndThree{a,b -> a+b}
The result is 5
>> twoAndThree{a,b -> a*b}
The result is 6
```



확장함수인 filter 구현 해보기

```kotlin
fun String.filter2(predicate: (Char) -> Boolean): String {
    
    val sb = StringBuilder()
    for(index in 0 until length){  //"abc" 문자열 length 만큼 반복 
        val element = get(index) //"abc"에서 char 요소 각각 가져오기
        if(predicate(element)){ // 'a'..'z' 에 포함된 문자인지 확인
           sb.append(element) //포함이 되어있으면 append
        } 
    }

    return sb.toString()
}

>>println("abc".filter2{ it in 'a'..'z'})
abc
```



#### 자바에서 코틀린 함수 타입 사용



#### 디폴트 값을 지정한 함수 타입 파라미터

파라미터를 함수타입으로 선언 할 때도 디폴트값을 정할 수 있음

```kotlin
// 컬렉션에 접두사,접미사,구분자를 붙여 문자열로 출력하는 함수

fun <T> Collection<T>.joinToString(
    separator: String=", ",
    prefix: String= "",
    postfix: String= "", 
    transform: (T) -> String = {it.toString()} //문자열 변환하는 로직을 default로 
) : String{
    val result = StringBuilder(prefix)
    for((index,element) in this.withIndex()){
        if(index>0) result.append(separator)
        result.append(transform(element))
    }
    result.append(postfix)

    return result.toString()
}
```

- 메소드를 호출할 때 매번 문자열로 변환하는 동작을 람다로 넘기지 않아도 됨
- 다른 동작을 수행해야 될 경우 람다에 변환 로직을 포함하여 파라미터로 넘기면 됨



#### Null 이 될 수 있는 함수타입 파라미터

```kotlin
fun <T> Collection<T>.joinToString(
    separator: String=", ",
    prefix: String= "",
    postfix: String= "",
    transform: ((T) -> String)? = null //Null이 될 수 있는 함수타입의 파라미터
) : String{
    val result = StringBuilder(prefix)
    for((index,element) in this.withIndex()){
        if(index>0) result.append(separator)
        val str = transform?.invoke(element) //안전 호출?
        	?: element.toString() //엘비스 연산자를 사용하여 함수 파라미터를 null 로받은경우 처리
        result.append(str)
    }
    result.append(postfix)

    return result.toString()
}
```



#### 함수를 함수에서 반환

함수를 파라미터로 받는 경우보다 자주쓰이지는 않지만 반환 값으로 함수를 받을 수 있다. 유용한 경우?

```kotlin
enum class Delivery { STANDARD, EXPEDITED }

class Order(val itemCount: Int)

fun getShippingCostCalculator(delivery: Delivery):(Order) -> Double{ //함수를 반환
    if (delivery == Delivery.EXPEDITED) {
    	return { order -> 6+2.1 * order.itemCount  } //함수에서 람다를 반환
    }

    return { order -> 1.2 * order.itemCount } //함수에서 람다를 반환
}


>> val calculator = getShippingCostCalculator(Delivery.EXPEDITED)
>> println(calculator(Order(3)))
12.3
```



#### 람다를 활용한 중복 제거

함수타입과 람다를 활용 하면 중복을 줄여 코드를 간결하게 표현할 수 있음

